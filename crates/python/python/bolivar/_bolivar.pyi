"""Type stubs for the native bolivar._bolivar extension module.

Generated from PyO3 Rust bindings in crates/python/src/.
"""

from collections.abc import Iterator, Sequence
from typing import Any, BinaryIO

# Type aliases for common shapes
_Matrix = tuple[float, float, float, float, float, float]
_Point = tuple[float, float]
_Rect = tuple[float, float, float, float]
_Color = list[float] | None
_DashingStyle = tuple[list[float], float] | None
_PathSegment = tuple[Any, ...]

# ── Constants ────────────────────────────────────────────────────────────

__version__: str
PDFDocEncoding: str
INF: int
MATRIX_IDENTITY: _Matrix
KEYWORD_PROC_BEGIN: PSKeyword
KEYWORD_PROC_END: PSKeyword
KEYWORD_ARRAY_BEGIN: PSKeyword
KEYWORD_ARRAY_END: PSKeyword
KEYWORD_DICT_BEGIN: PSKeyword
KEYWORD_DICT_END: PSKeyword

# ── casting.rs ───────────────────────────────────────────────────────────

def safe_int(obj: Any, /) -> int | None: ...
def safe_float(obj: Any, /) -> float | None: ...
def safe_matrix(
    a: Any, b: Any, c: Any, d: Any, e: Any, f: Any, /
) -> _Matrix | None: ...
def safe_rgb(r: Any, g: Any, b: Any, /) -> tuple[float, float, float] | None: ...
def safe_cmyk(
    c: Any, m: Any, y: Any, k: Any, /
) -> tuple[float, float, float, float] | None: ...
def safe_rect(a: Any, b: Any, c: Any, d: Any, /) -> _Rect | None: ...
def safe_rect_list(obj: Any, /) -> _Rect | None: ...

# ── utils.rs ─────────────────────────────────────────────────────────────

def mult_matrix(m1: _Matrix, m0: _Matrix, /) -> _Matrix: ...
def translate_matrix(m: _Matrix, v: _Point, /) -> _Matrix: ...
def apply_matrix_pt(m: _Matrix, v: _Point, /) -> _Point: ...
def apply_matrix_rect(m: _Matrix, rect: _Rect, /) -> _Rect: ...
def format_int_alpha(value: int, /) -> str: ...
def format_int_roman(value: int, /) -> str: ...
def shorten_str(s: str, size: int, /) -> str: ...
def reorder_text_for_output(text: str, /) -> str: ...
def unpad_aes(data: bytes | bytearray, /) -> bytes: ...

class Plane:
    def __init__(self, bbox: _Rect, gridsize: int = 50) -> None: ...
    def add(self, obj: Any, /) -> None: ...
    def extend(self, objs: Sequence[Any], /) -> None: ...
    def remove(self, obj: Any, /) -> bool: ...
    def find(self, bbox: _Rect, /) -> list[Any]: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...

# ── codec.rs ─────────────────────────────────────────────────────────────

def ascii85decode(data: bytes | bytearray, /) -> bytes: ...
def asciihexdecode(data: bytes | bytearray, /) -> bytes: ...
def lzwdecode(data: bytes | bytearray, /) -> bytes: ...
def lzwdecode_with_earlychange(
    data: bytes | bytearray, early_change: int = 1, /
) -> bytes: ...
def rldecode(data: bytes | bytearray, /) -> bytes: ...

class Arcfour:
    def __init__(self, key: bytes | bytearray, /) -> None: ...
    def process(self, data: bytes | bytearray, /) -> bytes: ...

class CCITTG4Parser:
    _curline: list[int]
    _curpos: int
    _color: int
    def __init__(self, width: int, bytealign: bool = False) -> None: ...
    def _reset_line(self) -> None: ...
    def _do_vertical(self, dx: int, /) -> None: ...
    def _do_pass(self) -> None: ...
    def _do_horizontal(self, n1: int, n2: int, /) -> None: ...
    def _get_bits(self) -> str: ...
    def feedbytes(self, data: bytes | bytearray, /) -> None: ...

class CCITTFaxDecoder:
    def __init__(
        self, width: int, bytealign: bool = False, reversed: bool = False
    ) -> None: ...
    def feedbytes(self, data: bytes | bytearray, /) -> None: ...
    def output_line(
        self, y: int, bits: bytes | bytearray | Sequence[int], /
    ) -> None: ...
    def close(self) -> bytes: ...

# ── document.rs ──────────────────────────────────────────────────────────

def LIT(name: str | bytes, /) -> PSLiteral: ...
def KWD(name: str | bytes, /) -> PSKeyword: ...
def decode_text(data: bytes | bytearray, /) -> str: ...
def isnumber(obj: Any, /) -> bool: ...

class PSLiteral:
    @property
    def name(self) -> bytes: ...
    def __init__(self, name: str | bytes, /) -> None: ...
    def __repr__(self) -> str: ...

class PSKeyword:
    @property
    def name(self) -> bytes: ...
    def __init__(self, name: str | bytes, /) -> None: ...
    def __repr__(self) -> str: ...

class PSBaseParser:
    def __init__(self, fp: BinaryIO | bytes | bytearray, /) -> None: ...
    def nexttoken(self) -> tuple[int, Any]: ...
    def tell(self) -> int: ...
    def seek(self, pos: int, /) -> None: ...

class PSStackParser:
    def __init__(self, fp: BinaryIO | bytes | bytearray, /) -> None: ...
    def nextobject(self) -> tuple[int, Any]: ...

class PDFParser:
    KEYWORD_NULL: None
    def __init__(self, fp: BinaryIO | bytes | bytearray, /) -> None: ...
    def get_data(self) -> bytes: ...
    def get_path(self) -> str | None: ...
    def nextobject(self) -> tuple[int, Any]: ...

class PDFStream:
    @property
    def attrs(self) -> dict[str, Any]: ...
    @property
    def rawdata(self) -> bytes: ...
    @property
    def decipher(self) -> None: ...
    def __init__(
        self, attrs: dict[str, Any], rawdata: bytes | str, doc: Any = None
    ) -> None: ...
    def get_data(self) -> bytes: ...
    def get_rawdata(self) -> bytes: ...
    def __repr__(self) -> str: ...

class PDFDocument:
    @property
    def info(self) -> list[dict[str, Any]]: ...
    @property
    def xrefs(self) -> list[dict[str, Any]]: ...
    @property
    def xref_objids(self) -> list[list[int]]: ...
    @property
    def xref_fallbacks(self) -> list[bool]: ...
    @property
    def catalog(self) -> dict[str, Any]: ...
    def __init__(
        self,
        data: bytes | bytearray,
        password: str = "",
        caching: bool = True,
    ) -> None: ...
    @classmethod
    def from_path(
        cls,
        path: str,
        password: str = "",
        caching: bool = True,
    ) -> PDFDocument: ...
    def get_pages(self) -> list[PDFPage]: ...
    def page_count(self) -> int: ...
    def page_mediaboxes(self) -> list[_Rect]: ...
    def get_page_labels(self) -> list[str]: ...
    def get_page(self, index: int, /) -> PDFPage: ...
    def getobj(self, objid: int, /) -> Any: ...

class PDFPage:
    pageid: int
    mediabox: _Rect | None
    cropbox: _Rect | None
    bleedbox: _Rect | None
    trimbox: _Rect | None
    artbox: _Rect | None
    rotate: int
    label: str | None
    @property
    def annots(self) -> list[Any]: ...
    @property
    def attrs(self) -> dict[str, Any]: ...
    @property
    def resources(self) -> dict[str, Any]: ...
    def __repr__(self) -> str: ...

class PDFResourceManager:
    @property
    def caching(self) -> bool: ...
    def __init__(self, caching: bool = True) -> None: ...
    def get_font(self, objid: int | None, spec: Any, /) -> int: ...

class NumberTree:
    @property
    def values(self) -> list[tuple[int, Any]]: ...
    def __init__(self, obj: Any, /) -> None: ...
    def lookup(self, key: int, /) -> Any: ...
    def __iter__(self) -> Iterator[tuple[int, Any]]: ...

# ── font.rs ──────────────────────────────────────────────────────────────

def name2unicode(name: str, /) -> str: ...
def glyphname2unicode() -> dict[str, str]: ...
def latin_encoding() -> list[tuple[str, int, int, int, int]]: ...
def font_metrics() -> dict[str, tuple[dict[str, Any], dict[str, float]]]: ...
def get_widths(seq: Sequence[Any], /) -> dict[int, float]: ...

class CMap:
    @property
    def attrs(self) -> dict[str, str]: ...
    @property
    def code2cid(self) -> dict[int, Any]: ...
    def __init__(self) -> None: ...
    def decode(self, data: bytes | bytearray, /) -> tuple[int, ...]: ...
    def __repr__(self) -> str: ...

class IdentityCMap:
    def __init__(self, vertical: bool = False) -> None: ...
    def decode(self, data: bytes | bytearray, /) -> tuple[int, ...]: ...

class IdentityCMapByte:
    def __init__(self, vertical: bool = False) -> None: ...
    def decode(self, data: bytes | bytearray, /) -> tuple[int, ...]: ...

class UnicodeMap:
    @property
    def cid2unichr(self) -> dict[int, str]: ...
    def __init__(self) -> None: ...
    def get_unichr(self, cid: int, /) -> str | None: ...
    def __repr__(self) -> str: ...

class CMapDB:
    @classmethod
    def is_identity_cmap(cls, name: str, /) -> bool: ...
    @classmethod
    def is_identity_cmap_byte(cls, name: str, /) -> bool: ...
    @classmethod
    def is_cjk_2byte_cmap(cls, name: str, /) -> bool: ...
    @classmethod
    def is_vertical(cls, name: str, /) -> bool: ...
    @classmethod
    def get_cmap(cls, name: str, /) -> CMap | IdentityCMap | IdentityCMapByte: ...
    @classmethod
    def get_unicode_map(cls, name: str, /, vertical: bool = False) -> UnicodeMap: ...

class EncodingDB:
    @classmethod
    def get_encoding(
        cls, name: str, /, diff: Sequence[Any] | None = None
    ) -> dict[int, str]: ...

class PDFFont:
    def __init__(
        self,
        descriptor: Any,
        widths: dict[int, float | None],
        default_width: float = 0.0,
    ) -> None: ...
    def to_unichr(self, cid: int, /) -> str | None: ...
    def char_width(self, cid: int, /) -> float: ...

class PDFCIDFont:
    @property
    def cmap(self) -> CMap | IdentityCMap | IdentityCMapByte: ...
    def __init__(
        self, rsrcmgr: Any, spec: dict[str, Any], strict: bool = False
    ) -> None: ...
    def get_cmap_from_spec(
        self, spec: Any, strict: bool = False
    ) -> CMap | IdentityCMap | IdentityCMapByte: ...
    def char_width(self, cid: int, /) -> float: ...
    def to_unichr(self, cid: int, /) -> str | None: ...

# ── image.rs ─────────────────────────────────────────────────────────────

class ImageWriter:
    def __init__(self, output_dir: str, /) -> None: ...
    def export_image(
        self,
        name: str,
        stream: PDFStream,
        srcsize: tuple[int, int] | None = None,
        bits: int = 8,
        colorspace: list[str] | None = None,
    ) -> str: ...

# ── params.rs ────────────────────────────────────────────────────────────

class LAParams:
    line_overlap: float
    char_margin: float
    line_margin: float
    word_margin: float
    boxes_flow: float | None
    detect_vertical: bool
    all_texts: bool
    def __init__(
        self,
        line_overlap: float = 0.5,
        char_margin: float = 2.0,
        line_margin: float = 0.5,
        word_margin: float = 0.1,
        boxes_flow: float | None = 0.5,
        detect_vertical: bool = False,
        all_texts: bool = False,
    ) -> None: ...
    def __repr__(self) -> str: ...

# ── layout.rs ────────────────────────────────────────────────────────────

class LTPage:
    pageid: int
    rotate: float
    @property
    def bbox(self) -> _Rect: ...
    @property
    def x0(self) -> float: ...
    @property
    def y0(self) -> float: ...
    @property
    def x1(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    def __repr__(self) -> str: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...

class LTChar:
    fontname: str
    size: float
    upright: bool
    adv: float
    matrix: _Matrix
    mcid: int | None
    tag: str | None
    non_stroking_color: _Color
    stroking_color: _Color
    def get_text(self) -> str: ...
    @property
    def ncs(self) -> PSLiteral | None: ...
    @property
    def scs(self) -> PSLiteral | None: ...
    @property
    def graphicstate(self) -> Any: ...
    @property
    def bbox(self) -> _Rect: ...
    @property
    def x0(self) -> float: ...
    @property
    def y0(self) -> float: ...
    @property
    def x1(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    def __repr__(self) -> str: ...

class LTAnno:
    text: str
    def __init__(self, text: str, /) -> None: ...
    def get_text(self) -> str: ...
    def __repr__(self) -> str: ...

class LTTextLineHorizontal:
    @property
    def bbox(self) -> _Rect: ...
    @property
    def x0(self) -> float: ...
    @property
    def y0(self) -> float: ...
    @property
    def x1(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    def get_text(self) -> str: ...
    def __iter__(self) -> Iterator[LTChar | LTAnno]: ...
    def __len__(self) -> int: ...

class LTTextLineVertical:
    @property
    def bbox(self) -> _Rect: ...
    @property
    def x0(self) -> float: ...
    @property
    def y0(self) -> float: ...
    @property
    def x1(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    def get_text(self) -> str: ...
    def __iter__(self) -> Iterator[LTChar | LTAnno]: ...
    def __len__(self) -> int: ...

class LTTextBoxHorizontal:
    @property
    def bbox(self) -> _Rect: ...
    @property
    def x0(self) -> float: ...
    @property
    def y0(self) -> float: ...
    @property
    def x1(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    def get_text(self) -> str: ...
    def __iter__(self) -> Iterator[LTTextLineHorizontal]: ...
    def __len__(self) -> int: ...

class LTTextBoxVertical:
    @property
    def bbox(self) -> _Rect: ...
    @property
    def x0(self) -> float: ...
    @property
    def y0(self) -> float: ...
    @property
    def x1(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    def get_text(self) -> str: ...
    def __iter__(self) -> Iterator[LTTextLineVertical]: ...
    def __len__(self) -> int: ...

class LTImage:
    name: str
    srcsize: tuple[int | None, int | None]
    imagemask: bool
    bits: int
    colorspace: list[str]
    @property
    def bbox(self) -> _Rect: ...
    @property
    def x0(self) -> float: ...
    @property
    def y0(self) -> float: ...
    @property
    def x1(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...

class LTFigure:
    name: str
    matrix: _Matrix
    @property
    def bbox(self) -> _Rect: ...
    @property
    def x0(self) -> float: ...
    @property
    def y0(self) -> float: ...
    @property
    def x1(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...

class LTRect:
    linewidth: float
    stroke: bool
    fill: bool
    non_stroking_color: _Color
    stroking_color: _Color
    dashing_style: _DashingStyle
    mcid: int | None
    tag: str | None
    @property
    def original_path(self) -> list[Any] | None: ...
    @original_path.setter
    def original_path(self, value: list[Any] | None) -> None: ...
    def __init__(
        self,
        linewidth: float,
        pts: list[_Point],
        stroke: bool = False,
        fill: bool = False,
        evenodd: bool = False,
        stroking_color: Any = None,
        non_stroking_color: Any = None,
        dashing: Any = None,
    ) -> None: ...
    @property
    def bbox(self) -> _Rect: ...
    @property
    def x0(self) -> float: ...
    @property
    def y0(self) -> float: ...
    @property
    def x1(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    def __repr__(self) -> str: ...

class LTLine:
    p0: _Point
    p1: _Point
    linewidth: float
    stroke: bool
    fill: bool
    non_stroking_color: _Color
    stroking_color: _Color
    dashing_style: _DashingStyle
    mcid: int | None
    tag: str | None
    @property
    def original_path(self) -> list[Any] | None: ...
    @original_path.setter
    def original_path(self, value: list[Any] | None) -> None: ...
    def __init__(
        self,
        linewidth: float,
        pts: list[_Point],
        stroke: bool = False,
        fill: bool = False,
        evenodd: bool = False,
        stroking_color: Any = None,
        non_stroking_color: Any = None,
        dashing: Any = None,
    ) -> None: ...
    @property
    def bbox(self) -> _Rect: ...
    @property
    def x0(self) -> float: ...
    @property
    def y0(self) -> float: ...
    @property
    def x1(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    @property
    def pts(self) -> list[_Point]: ...
    def __repr__(self) -> str: ...

class LTCurve:
    pts: list[_Point]
    linewidth: float
    stroke: bool
    fill: bool
    evenodd: bool
    non_stroking_color: _Color
    stroking_color: _Color
    dashing_style: _DashingStyle
    mcid: int | None
    tag: str | None
    @property
    def original_path(self) -> list[Any] | None: ...
    @original_path.setter
    def original_path(self, value: list[Any] | None) -> None: ...
    def __init__(
        self,
        linewidth: float,
        pts: list[_Point],
        stroke: bool = False,
        fill: bool = False,
        evenodd: bool = False,
        stroking_color: Any = None,
        non_stroking_color: Any = None,
        dashing: Any = None,
    ) -> None: ...
    @property
    def bbox(self) -> _Rect: ...
    @property
    def x0(self) -> float: ...
    @property
    def y0(self) -> float: ...
    @property
    def x1(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    def __repr__(self) -> str: ...

class TextConverter:
    def __init__(
        self,
        rsrcmgr: Any,
        outfp: Any,
        codec: str = "utf-8",
        pageno: int = 1,
        laparams: LAParams | None = None,
        showpageno: bool = False,
        imagewriter: Any = None,
    ) -> None: ...
    def _receive_layout(self, ltpage: LTPage, /) -> None: ...
    def close(self) -> None: ...

class HTMLConverter:
    def __init__(
        self,
        rsrcmgr: Any,
        outfp: Any,
        codec: str = "utf-8",
        pageno: int = 1,
        laparams: LAParams | None = None,
        scale: float = 1.0,
        fontscale: float = 1.0,
        layoutmode: str = "normal",
        showpageno: bool = True,
        pagemargin: int = 50,
        imagewriter: Any = None,
        debug: int = 0,
        rect_colors: dict[str, str] | None = None,
        text_colors: dict[str, str] | None = None,
    ) -> None: ...
    def _receive_layout(self, ltpage: LTPage, /) -> None: ...
    def close(self) -> None: ...

class XMLConverter:
    def __init__(
        self,
        rsrcmgr: Any,
        outfp: Any,
        codec: str = "utf-8",
        pageno: int = 1,
        laparams: LAParams | None = None,
        stripcontrol: bool = False,
        imagewriter: Any = None,
    ) -> None: ...
    def _receive_layout(self, ltpage: LTPage, /) -> None: ...
    def close(self) -> None: ...

class HOCRConverter:
    def __init__(
        self,
        rsrcmgr: Any,
        outfp: Any,
        codec: str = "utf-8",
        pageno: int = 1,
        laparams: LAParams | None = None,
        stripcontrol: bool = False,
        imagewriter: Any = None,
    ) -> None: ...
    def _receive_layout(self, ltpage: LTPage, /) -> None: ...
    def close(self) -> None: ...

class TagExtractor:
    def __init__(self, rsrcmgr: Any, outfp: Any, codec: str = "utf-8") -> None: ...
    def begin_tag(self, tag: Any, props: Any = None) -> None: ...
    def end_tag(self) -> None: ...
    def do_tag(self, tag: Any, props: Any = None) -> None: ...
    def write(self, text: str, /) -> None: ...
    def pageno(self) -> int: ...
    def increment_pageno(self) -> None: ...
    def close(self) -> None: ...

# ── table.rs ─────────────────────────────────────────────────────────────

def extract_text(
    data: bytes | bytearray | BinaryIO,
    password: str = "",
    page_numbers: Sequence[int] | None = None,
    maxpages: int = 0,
    caching: bool = True,
    laparams: LAParams | None = None,
) -> str: ...
def extract_text_from_path(
    path: str,
    password: str = "",
    page_numbers: Sequence[int] | None = None,
    maxpages: int = 0,
    caching: bool = True,
    laparams: LAParams | None = None,
) -> str: ...
def extract_pages(
    data: bytes | bytearray | BinaryIO,
    password: str = "",
    page_numbers: Sequence[int] | None = None,
    maxpages: int = 0,
    caching: bool = True,
    laparams: LAParams | None = None,
) -> list[LTPage]: ...
def extract_pages_from_path(
    path: str,
    password: str = "",
    page_numbers: Sequence[int] | None = None,
    maxpages: int = 0,
    caching: bool = True,
    laparams: LAParams | None = None,
) -> list[LTPage]: ...
def extract_pages_with_images(
    data: bytes | bytearray | BinaryIO,
    output_dir: str,
    password: str = "",
    page_numbers: Sequence[int] | None = None,
    maxpages: int = 0,
    caching: bool = True,
    laparams: LAParams | None = None,
) -> list[LTPage]: ...
def extract_pages_with_images_from_path(
    path: str,
    output_dir: str,
    password: str = "",
    page_numbers: Sequence[int] | None = None,
    maxpages: int = 0,
    caching: bool = True,
    laparams: LAParams | None = None,
) -> list[LTPage]: ...
def process_page(
    doc: PDFDocument,
    page: PDFPage,
    laparams: LAParams | None = None,
) -> LTPage: ...
def process_pages(
    doc: PDFDocument,
    laparams: LAParams | None = None,
) -> list[LTPage]: ...
def extract_tables_from_document(
    doc: PDFDocument,
    geometries: Sequence[Any],
    table_settings: dict[str, Any] | None = None,
    laparams: LAParams | None = None,
) -> list[list[list[list[str | None]]]]: ...
def extract_tables_stream_from_document(
    doc: PDFDocument,
    geometries: Sequence[Any],
    table_settings: dict[str, Any] | None = None,
    laparams: LAParams | None = None,
    page_numbers: Sequence[int] | None = None,
    maxpages: int = 0,
    caching: bool = True,
) -> PyTableStream: ...
def _extract_tables_core(
    doc: PDFDocument,
    page_index: int,
    page_bbox: _Rect,
    mediabox: _Rect,
    initial_doctop: float = 0.0,
    table_settings: dict[str, Any] | None = None,
    laparams: LAParams | None = None,
    force_crop: bool = False,
) -> list[list[list[str | None]]]: ...
def _extract_tables_from_page_objects(
    objects: dict[str, Any],
    page_bbox: Any,
    mediabox: Any,
    initial_doctop: float = 0.0,
    table_settings: dict[str, Any] | None = None,
    force_crop: bool = False,
) -> list[list[list[str | None]]]: ...
def repair_pdf(data: bytes | bytearray | BinaryIO, /) -> bytes: ...

# ── stream.rs ────────────────────────────────────────────────────────────

def async_runtime_poc() -> Any: ...
def extract_pages_async(
    data: bytes | bytearray | BinaryIO,
    password: str = "",
    page_numbers: Sequence[int] | None = None,
    maxpages: int = 0,
    caching: bool = True,
    laparams: LAParams | None = None,
) -> _AsyncPageStream: ...
def extract_pages_async_from_document(
    doc: PDFDocument,
    page_numbers: Sequence[int] | None = None,
    maxpages: int = 0,
    caching: bool = True,
    laparams: LAParams | None = None,
) -> _AsyncPageStream: ...

class _AsyncPageStream:
    def __aiter__(self) -> _AsyncPageStream: ...
    async def __anext__(self) -> LTPage: ...
    async def aclose(self) -> None: ...

class PyTableStream:
    def __iter__(self) -> PyTableStream: ...
    def __next__(self) -> tuple[int, list[list[list[str | None]]]]: ...
